апи:

1) резервирование
func (id складов, id клиента, id итемов) (ашипка)
1 склад: просто проверяем, хватает ли товаров на этом складе
бд: func (id склада, id клиента, id итемов) (ашипка)
селект на наличие товара на складе (тут же проверяем что его хватит на заказ)
reservations хранит в себе status: "created", "deleted", "applied"

>1 склада: пиздец

2) освобождаение резервации
func (id клиента) (ашипка) // убирает нахуй все резервации клиента
Получаем все резервации, раскидываем на map[store_id][]items
и для каждого элемента мапы вызываем функцию обновления данных в бд
бд: func (id клиента) (ашипка)
селект по айди клиента и статусу "created" у его записей в reservations
меняем статус на "deleted"
сделать триггер на пост апдейт поля статус (чтоб брал в себя id клиента, смотрел апдейты "deleted" и из этой строки закидывал в id стора amount из этой же строки)

3) просмотр остатов на складе
func (id склада, сортировка (по убыванию/возрастанию), offset, кол-во страниц которые хотим забрать) (ашипка)
просто select на store_item с ASC/DESC и OFFSET. Если оффсета нет - забираем всё и делаем пагинацию по 5 элементов на страницу. 


бд
триггеры
1) на заполнение amount в item (триггер на инсерт и апдейт в store_item)
сделать вьюху которая будет отображать сумму amount всех товаров с группировкой по id товара




goose:

goose -dir app/internal/storage/migrations postgres "postgresql://admin:admin@127.0.0.1:5432/stores?sslmode=disable" up

goose -dir app/internal/storage/migrations postgres "postgresql://admin:admin@127.0.0.1:5432/stores?sslmode=disable" down-to 0













DECLARE @Item_id = $1

WITH all_items_in_all_stores
AS
(SELECT store_id, amount
FROM store_item
WHERE item_id = '1' AND amount != 0
ORDER BY store_item.amount ASC)

DECLARE @Want_amount = 1000
DECLARE @Have_now = 0
DECLARE @Store_counter = 1

SELECT @Have_now = SUM(amount)
FROM all_items_in_all_stores
IF @Want_amount > @Have_now
	--return
  
@Have_now = 0

WHILE (@Have_now < @Want_amount)
BEGIN
	SELECT @Have_now = SUM(amount)
	FROM all_items_in_all_stores
  OFFSET @Store_counter;
	IF @Have_now < @Want_amount
  	@Store_counter = @Store_counter + 1
    CONTINUE
  ELSE
    IF @Store_counter = 1
    	UPDATE store_item
      SET amount = amount - @Want_amount
      @Store_counter = @Store_counter - 1
    ELSE
    	UPDATE store_item
      SET amount = 0
      WHERE item_id = @Item_id AND store_id IN
      (SELECT store_id
      FROM all_items_in_all_stores
      OFFSET @Store_counter - 1)
    
END

















CREATE OR REPLACE FUNCTION create_reservation_one_store(VARCHAR, VARCHAR, VARCHAR, INTEGER)
RETURNS INTEGER AS $$
DECLARE 
Client_id VARCHAR;
Store_id VARCHAR;
Item_id VARCHAR;
Amount INTEGER;
Amount_in_store INTEGER;
BEGIN
	Client_id := $1;
	Store_id := $2;
	Item_id := $3;
	Amount := $4;
  
	SELECT Amount_in_store = amount
  FROM store_item
  WHERE store_id = @Store_id AND item_id = @Item_id;
  IF Amount_in_store > @amount
  	INSERT INTO reservations (client_id, store_id, item_id, amount, status)
    VALUES (@Client_id, @Store_id, @Item_id, @Amount, 'created')
    THEN RETURN 1
  ELSE
  	THEN RETURN 0
END;
$$
 LANGUAGE plpgsql;






CREATE OR REPLACE FUNCTION create_reservation_one_store(in_client_id VARCHAR, in_store_id VARCHAR, in_item_id VARCHAR, in_amount INTEGER)
RETURNS INTEGER AS $$
DECLARE
Amount_in_store INTEGER;
BEGIN  
	SELECT Amount_in_store = amount
  FROM store_item
  WHERE store_id = in_store_id AND item_id = in_item_id;
  IF Amount_in_store > in_amount
  	INSERT INTO reservations (client_id, store_id, item_id, amount, status) 
    VALUES (in_client_id, in_store_id, in_item_id, in_amount, 'created')
  	RETURN 1;
  ELSE
  	RETURN 0;
END;
$$
 LANGUAGE plpgsql;

























CREATE OR REPLACE FUNCTION create_reservation_many_stores(in_client_id VARCHAR, in_store_ids INTEGER[], in_item_id VARCHAR, in_amount INTEGER)
RETURNS INTEGER AS 
$$
DECLARE
	Exec_code INTEGER;
  Have_now INTEGER;
  Store_counter INTEGER;
BEGIN
WITH required_stores_item
AS
(SELECT store_id, amount
FROM store_item
WHERE store_id = ANY(in_store_ids) AND item_id = in_item_id AND amount != 0
ORDER BY store_item.amount ASC)

SELECT Have_now = SUM(amount)
FROM required_stores_item;
IF in_amount > Have_now THEN
	Exec_code := 0;
  RETURN Exec_code;
END IF;
  
Have_now = 0;
Store_counter = 1;

WHILE (Have_now < in_amount)
	SELECT Have_now = SUM(amount)
	FROM required_stores_item
  OFFSET Store_counter
  
	IF Have_now < in_amount THEN
  	Store_counter = Store_counter + 1
    CONTINUE
  ELSE
    IF Store_counter = 1 THEN
    	UPDATE store_item
      SET amount = amount - in_amount
      WHERE item_id = in_item_id AND store_id IN
      (SELECT store_id
      FROM required_stores_item
      OFFSET Store_counter)
      Exec_code := 1
  		RETURN Exec_code
      LOOP;
    ELSE
    	UPDATE store_item
      SET amount = 0
      WHERE item_id = in_item_id AND store_id IN
      (SELECT store_id
      FROM required_stores_item
      OFFSET Store_counter - 1)
      
      UPDATE store_item
      SET amount = 0
      WHERE item_id = in_item_id AND store_id IN
      (SELECT store_id
      FROM required_stores_item
      OFFSET Store_counter
      LIMIT 1)
      
      Exec_code := 1
  		RETURN Exec_code
      LOOP;
    END IF;
  END IF;
END;
$$
	LANGUAGE plpgsql;


